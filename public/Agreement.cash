pragma cashscript ^0.6.3;

/**
 * @param: Pub key controlling the contract.
 * @param: Hash of the payer controled contract.
 * @param: payeePk's public key.
 * @param: Deadline after which the contract can be spendable by any party.
 * @param: maxAmountPerEpoch: Max spendable amount per epoch.
 * @param: epoch: The time frame that puts restriction on amount that can be spent.
 * @param: remaningAmount: The spendable amount left for each epoch.
 * @param: validFrom: The time of contract creation.
 */
contract Agreement(
        pubkey payerPk,
        bytes20 payerContractScriptHash,
        pubkey payeePk,
        bytes4 deadline,
        bytes4 maxAmountPerEpoch,
        bytes4 epoch,
        bytes4 remainingAmount,
        bytes4 validFrom)
    {
    // Warning: Only to be used in testing.
    function reclaim(sig s) {
        require(checkSig(s, payerPk));
    }

    // Can only be used by the owner of the contract.
    function revoke(sig s, int minerFee){
        // Make sure that the owner is making this transaction.
        require(checkSig(s, payerPk));
        // Verify that the transaction is older than current time.

        int changeAmount = int(bytes(tx.value)) - minerFee;

        // Send the funds back to the payer contract.
        bytes32 output = new OutputP2SH(bytes8(changeAmount), payerContractScriptHash);
        require(tx.hashOutputs == hash256(output));
    }

    // Can only be used by the owner of the contract.
    // function revokeFairly(sig s, int minerFee){
    //     // Make sure that the owner is making this transaction.
    //     require(checkSig(s, payerPk));
    //     // Verify that the transaction is older than current time.
    //     int validFromI = int(validFrom);
    //     int passedTime = tx.locktime - validFromI; // Blocks passed

    //     require(passedTime < epoch);
    //     int returnFraction = epoch/passedTime;
    //     int returnAmount = maxAmountPerEpoch/returnFraction;
    //     require(returnAmount <= remainingAmount);

    //     int changeAmount = int(bytes(tx.value)) - minerFee - returnAmount;

    //     // Send the funds back to the payer contract.
    //     bytes32 toPayee = new OutputP2SH(bytes8(returnAmount), hash160(payeePk));
    //     bytes32 toPayer = new OutputP2SH(bytes8(changeAmount), payerContractScriptHash);
    //     require(tx.hashOutputs == hash256(toPayee + toPayer));
    // }

    // Spend the amount with the permission from the payer.
    // function spendWithSig(
    //     sig s,
    //     datasig signature,
    //     bytes message,
    //     bytes20 recipientPkh
    // ) {
    //     require(checkSig(s, payeePk)); // Make sure that only payee can make this transaction.
    //     require(checkDataSig(signature, message, payerPk)); // Make sure that the payer signed the message of a specific amount.
    //     int amount = int(message);
        
    //     int changeAmount = spendableRemainingAmount - minerFee - amount;
    //     // Send the amount to the any recipient's address.
    //     bytes34 toRecipient = new OutputP2PKH(bytes8(amount), recipientPkh);
    //     require(hash256(toRecipient) == tx.hashOutputs);
    // }

    // Can only be used by the payeePk of the contract.
    function spend(
        sig s,
        int minerFee,
        int amount,
        bytes20 recipientPkh // Needs to be taken care off.
    ) {
        require(checkSig(s, payeePk)); // Make sure that only payee can make this transaction.
        int spendableRemainingAmount = int(remainingAmount);
        int validFromInt = int(validFrom);
        // require(tx.time >= validFromInt);          // Make sure that we are not spending a contract with a blockheight less than the current height.
        
        int passedTime = int(tx.locktime) - validFromInt; // To check whether a new epoch has started.
        int changeAmount = int(bytes(tx.value)) - minerFee - amount;

        // Make sure that we are waiting atleast `epoch` to be able to spend funds again.
        if (passedTime >= int(epoch)){
            // If epoch is passed then reset the remainingAmount to maxAmountPerEpoch
            // but subtract the amount that will be spend in this transaction.
            require(amount <= int(maxAmountPerEpoch));
            spendableRemainingAmount = int(maxAmountPerEpoch) - amount;
        } else {
            require(amount <= spendableRemainingAmount); 
        }

        // Send the amount to the any recipient's address.
        bytes34 toRecipient = new OutputP2PKH(bytes8(amount), recipientPkh);

        if (changeAmount > 546) {
            // Create a new contract with timelock as the current or provided locktime during contract building.
            // Note that the constructor parameters are added in the reverse order.
            // So initial block is actually the first statement in the contract bytecode.
            bytes nextState = 0x04 + tx.locktime + 0x04 + bytes4(spendableRemainingAmount) + tx.bytecode.split(5)[1];
        
            // Create a simulated state(Helps in enforcing spendable restrictions) by sending the money to the new contract with same
            // parameters except the timelock.
            bytes32 toContract = new OutputP2SH(bytes8(changeAmount), hash160(nextState));
            require(hash256(toRecipient + toContract) == tx.hashOutputs);
        } else {
            require(hash256(toRecipient) == tx.hashOutputs);
        }
    }

    // Might need this to maintain a chain of transactions and payments being done.
    function modify(
        sig payerSig,
        sig payeePkSig,
        int minerFee,
        bytes20 newAgreementScriptHash,
    ){
        // Make sure they both agree to the new changes.
        require(checkSig(payerSig, payerPk));
        require(checkSig(payeePkSig, payeePk));
        
        int changeAmount = int(bytes(tx.value)) - minerFee;
        // Add in the scripthash of the new contract that both parties can agree upon.
        bytes32 output = new OutputP2SH(bytes8(changeAmount), newAgreementScriptHash);
        require(tx.hashOutputs == hash256(output));

        // OR
        // bytes modifiedContract = 0x04 + newvalidFrom + 0x04 + epoch + 0x04 + newMaxAmountPerEpoch + tx.bytecode.split(15)[1];
        // bytes32 output = new OutputP2SH(bytes8(changeAmount), hash160(modifiedContract));
        // require(hash256(output) == tx.hashOutputs);

    }

    function claimExpiredContractFunds(pubkey pk, sig s) {
        // Funds can be spend by anyone making the contract obsolete.
        require(checkSig(s, pk));
        require(tx.time >= int(deadline));
    }
}