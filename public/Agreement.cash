pragma cashscript ^0.6.3;

/**
 * @param: Pub key controlling the contract.
 * @param: Hash of the payer controled contract.
 * @param: payeePk's public key.
 * @param: Deadline after which the contract can be spendable by any party.
 * @param: maxAmountPerEpoch: Max spendable amount per epoch.
 * @param: epoch: The time frame that puts restriction on amount that can be spent.
 * @param: remaningAmount: The spendable amount left for each epoch.
 * @param: validFrom: The time of contract creation.
 */
contract Agreement(
        pubkey payerPk,
        // bytes20 payerContractScriptHash,
        pubkey payeePk,
        // bytes4 deadline,
        bytes4 maxAmountPerEpoch,
        bytes4 epoch,
        bytes4 remainingTime,
        bytes4 remainingAmount,
        bytes4 validFrom)
    {
    // Warning: Only to be used in testing.
    // function reclaim(sig s) {
    //     require(checkSig(s, payerPk));
    // }

    // Can only be used by the owner of the contract.
    function revoke(sig s){
        // Make sure that the owner is making this transaction.
        require(checkSig(s, payerPk));
        // Verify that the transaction is older than current time.

        // int changeAmount = int(bytes(tx.value)) - minerFee;

        // Send the funds back to the payer contract.
        // bytes32 output = new OutputP2SH(bytes8(changeAmount), payerContractScriptHash);
        // require(tx.hashOutputs == hash256(output));
    }

    // Can only be used by the owner of the contract.
    // function revoke(sig s, int changeAmount){
    //     // Make sure that the owner is making this transaction.
    //     require(checkSig(s, payerPk));
    //     // Verify that the transaction is older than current time.

    //     // int changeAmount = int(bytes(tx.value)) - minerFee;

    //     // Send the funds back to the payer contract.
    //     bytes32 output = new OutputP2SH(bytes8(changeAmount), payerContractScriptHash);
    //     require(tx.hashOutputs == hash256(output));
    // }

    // Can only be used by the owner of the contract.
    // function revokeAlmostFairly(sig s, int minerFee){
    //     // Make sure that the owner is making this transaction.
    //     require(checkSig(s, payerPk));
    //     // Verify that the transaction is older than current time.
    //     int passedTime = int(tx.locktime) - int(validFrom); // Blocks passed

    //     int timeSinceLastEpoch = passedTime % int(epoch); // Only considering the time after the last epoch.
    //     int reverseFraction = int(epoch)/timeSinceLastEpoch;
    //     int returnAmount = int(maxAmountPerEpoch)/reverseFraction;
    
    //     require(returnAmount <= int(remainingAmount));

    //     int changeAmount = int(bytes(tx.value)) - minerFee - returnAmount;

    //     // Send the funds back to the payer contract.
    //     bytes32 toPayee = new OutputP2SH(bytes8(returnAmount), hash160(payeePk));
    //     bytes32 toPayer = new OutputP2SH(bytes8(changeAmount), payerContractScriptHash);
    //     require(tx.hashOutputs == hash256(toPayee + toPayer));
    // }

    // Spend the amount with the permission from the payer.
    // function spendWithSig(
    //     sig s,
    //     datasig signature,
    //     bytes message,
    //     bytes20 hash160(payeePk)
    // ) {
    //     require(checkSig(s, payeePk)); // Make sure that only payee can make this transaction.
    //     require(checkDataSig(signature, message, payerPk)); // Make sure that the payer signed the message of a specific amount.
    //     int amount = int(message);
        
    //     int changeAmount = newRemainingAmount - minerFee - amount;
    //     // Send the amount to the any recipient's address.
    //     bytes34 toRecipient = new OutputP2PKH(bytes8(amount), hash160(payeePk));
    //     require(hash256(toRecipient) == tx.hashOutputs);
    // }

    /**
     * @param: s: signature of the payeePk.
     * @param: amountToNextState: Amount sent should be greater than 546 i.e the dust limit
     * otherwise the contract will not execute.
     * @param: amount: Amount to be sent to the payeePkh
     */
    function spend(
        sig s,
        int amountToNextState,
        int amount,
    ) {
        // Make sure that only payee can make this transaction.
        require(checkSig(s, payeePk));
        int newRemainingAmount = int(remainingAmount);
        int newRemainingTime = int(remainingTime);
        // As a safety measure as this amount is used in further calculations.
        require(amount >= 546);
        require(amount <= int(maxAmountPerEpoch));

        int validFromTime = int(validFrom);
        // Make sure that we are not spending a contract with a blockheight less than the current height.
        require(tx.time >= validFromTime);

        // To check whether a new epoch has started.
        // 695538 - 695534 = 4 // Blocks.
        int passedTime = int(tx.locktime) - validFromTime;

        // Make sure that we are waiting atleast `epoch` to be able to spend funds again.
        // if (passedTime >= int(remainingTime)){
        int intEpoch = int(epoch);
        if (passedTime >= newRemainingTime){
            // Update the remaining days to max i.e epoch.
            int timeSinceLastEpoch = passedTime;
            if (passedTime >= intEpoch){
                timeSinceLastEpoch = passedTime % intEpoch;
                // If epoch is passed then reset the remainingAmount to maxAmountPerEpoch
                // but subtract the amount that will be spend in this transaction.
            } else {
                timeSinceLastEpoch = passedTime - newRemainingTime;
            }
            newRemainingTime = intEpoch - timeSinceLastEpoch;
            newRemainingAmount = int(maxAmountPerEpoch) - amount;
        } else {
            // Update the days left for reset to the current calculation of passedTime.
            // remainingTime = epoch - passedTime
            newRemainingTime = newRemainingTime - passedTime;
            newRemainingAmount = newRemainingAmount - amount;
        }

        // Create a new contract with timelock as the current or provided locktime during contract building.
        // Note that the constructor parameters are added in the reverse order.
        // So initial block is actually the first statement in the contract bytecode.
        bytes nextState = 0x04 + tx.locktime + 0x04 + bytes4(newRemainingAmount) + 0x04 + bytes4(newRemainingTime) + tx.bytecode.split(15)[1];
    
        // Create a simulated state(Helps in enforcing spendable restrictions) by sending the money to the new contract with same
        // parameters except the timelock.
        bytes34 toRecipient = new OutputP2PKH(bytes8(amount), hash160(payeePk));
        bytes32 toContract = new OutputP2SH(bytes8(amountToNextState), hash160(nextState));
        require(hash256(toRecipient + toContract) == tx.hashOutputs);
    }

    // Might need this to maintain a chain of transactions and payments being done.
    // function modify(
    //     sig payerSig,
    //     sig payeePkSig,
    //     int transferAmount,
    //     bytes20 newAgreementScriptHash,
    // ){
    //     // Make sure they both agree to the new changes.
    //     require(checkSig(payerSig, payerPk));
    //     require(checkSig(payeePkSig, payeePk));

    //     // Add in the scripthash of the new contract that both parties can agree upon.
    //     bytes32 output = new OutputP2SH(bytes8(transferAmount), newAgreementScriptHash);
    //     require(tx.hashOutputs == hash256(output));

    //     // OR
    //     // bytes modifiedContract = 0x04 + newvalidFrom + 0x04 + epoch + 0x04 + newMaxAmountPerEpoch + tx.bytecode.split(15)[1];
    //     // bytes32 output = new OutputP2SH(bytes8(transferAmount), hash160(modifiedContract));
    //     // require(hash256(output) == tx.hashOutputs);

    // }

    // function claimExpiredContractFunds(pubkey pk, sig s) {
    //     // Funds can be spend by anyone making the contract obsolete.
    //     require(checkSig(s, pk));
    //     require(int(tx.locktime) >= int(deadline));
    // }
}