pragma cashscript ^0.6.3;

/**
 * @param: Pub key controlling the contract.
 * @param: Hash of the payer controled contract.
 * @param: payeePk's public key.
 * @param: Deadline after which the contract can be spendable by any party.
 * @param: maxAmountPerEpoch: Max spendable amount per epoch.
 * @param: epoch: The time frame that puts restriction on amount that can be spent.
 * @param: remaningAmount: The spendable amount left for each epoch.
 * @param: validFrom: The time of contract creation.
 */
contract Agreement(
        pubkey payerPk,
        // bytes20 payerContractScriptHash,
        pubkey payeePk,
        // bytes4 deadline,
        bytes4 maxAmountPerEpoch,
        bytes4 epoch,
        bytes4 remainingTime,
        bytes4 remainingAmount,
        bytes4 validFrom)
    {

    // Can only be used by the owner of the contract.
    function revoke(sig s){
        // Make sure that the owner is making this transaction.
        require(checkSig(s, payerPk));
    }

    /**
     * @param: s: signature of the payeePk.
     * @param: amountToNextState: Amount sent should be greater than 546 i.e the dust limit
     * otherwise the contract will not execute.
     * @param: amount: Amount to be sent to the payeePkh
     */
    function spend(
        sig s,
        int amountToNextState,
        int amount,
    ) {
        // Make sure that only payee can make this transaction.
        require(checkSig(s, payeePk));
        int newRemainingAmount = int(remainingAmount);
        int newRemainingTime = int(remainingTime);
        // As a safety measure as this amount is used in further calculations.
        require(amount >= 546);
        require(amount <= int(maxAmountPerEpoch));

        int validFromTime = int(validFrom);
        // Make sure that we are not spending a contract with a blockheight less than the current height.
        require(tx.time >= validFromTime);

        // To check whether a new epoch has started.
        // 695538 - 695534 = 4 // Blocks.
        int passedTime = int(tx.locktime) - validFromTime;
        // require(passedTime > 0);
        // Make sure that we are waiting atleast `epoch` to be able to spend funds again.
        // if (passedTime >= int(remainingTime)){
        int intEpoch = int(epoch);
        if (passedTime >= newRemainingTime){
            // Update the remaining days to max i.e epoch.
            int timeSinceLastEpoch = passedTime;
            if (passedTime >= intEpoch){
                timeSinceLastEpoch = passedTime % intEpoch;
                // If epoch is passed then reset the remainingAmount to maxAmountPerEpoch
                // but subtract the amount that will be spend in this transaction.
            } else {
                timeSinceLastEpoch = passedTime - newRemainingTime;
            }
            newRemainingTime = intEpoch - timeSinceLastEpoch;
            newRemainingAmount = int(maxAmountPerEpoch) - amount;
        } else {
            // Update the days left for reset to the current calculation of passedTime.
            // remainingTime = epoch - passedTime
            newRemainingTime = newRemainingTime - passedTime;
            newRemainingAmount = newRemainingAmount - amount;
        }

        // Create a new contract with timelock as the current or provided locktime during contract building.
        // Note that the constructor parameters are added in the reverse order.
        // So initial block is actually the first statement in the contract bytecode.
        bytes nextState = 0x04 + tx.locktime + 0x04 + bytes4(newRemainingAmount) + 0x04 + bytes4(newRemainingTime) + tx.bytecode.split(15)[1];
    
        // Create a simulated state(Helps in enforcing spendable restrictions) by sending the money to the new contract with same
        // parameters except the timelock.
        bytes34 toRecipient = new OutputP2PKH(bytes8(amount), hash160(payeePk));
        bytes32 toContract = new OutputP2SH(bytes8(amountToNextState), hash160(nextState));
        require(hash256(toRecipient + toContract) == tx.hashOutputs);
    }
}